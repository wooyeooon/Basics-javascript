#### 배열 (Array)

```javascript
// .length  배열의 길이(숫자)를 반환한다.

const arr = ["A", "B", "C"];
console.log(arr.length); // 3
```

```javascript
// .at 대상 배열을 인덱싱한다. 음수 값을 사용하면 뒤에서부터 인덱싱한다.

const arr = ["A", "B", "C"];

console.log(arr[0]); // A
console.log(arr.at(0)); // A

console.log(arr[arr.length - 1]); // C
console.log(arr.at(-1)); // C
```

```javascript
// .concat()  대상 배열과 주어진 배열을 병합해 새로운 배열을 반환한다.

const arr1 = ["A", "B", "C"];
const arr1 = ["D", "E", "F"];
const arr3 = arr.concat(arr2);
const arr4 = [...arr1, ...ar2];

console.log(arr1); //['A', 'B', 'C']
console.log(arr2); //['D', 'E', 'F']
console.log(arr3); //['A', 'B', 'C', 'D', 'E', 'F']
console.log(arr4); //['A', 'B', 'C', 'D', 'E', 'F']
```

```javascript
//.every()  대상 배열의 모든 요소가 콜백 테스트에서 참으로 반환하는지 확인한다.

const arr = [1, 2, 3, 4];
const isValid = arr.every((item) => item < 5);

console.log(isValid); // true
```

```javascript
// filter()  주어진 콜백 테스트를 통과(참)하는 모든 요소를 새로운 배열로 반환한다.
// 모든 요소가 테스트를 통과하지 못하면 빈 배열을 반환한다.

const numbers = [1, 20, 7, 9, 104, 0, 58];
const filteredNumbers = numbers.filter((number) => number < 30);

console.log(filteredNumbers); // [1, 20, 7, 9, 0]

const users = [
  { name: "Neo", age: 45 },
  { name: "Kato", age: 22 },
  { name: "Amy", age: 17 },
];
const adults = users.filter((user) => user.age >= 19);
console.log(adults); // Object { Neo, Kato... }
```

```javascript
// .find()  대상 배열에서 콜백 테스트를 통과하는 첫 번째 요소를 반환한다.

const arr = [5, 8, 130, 12, 44];
const foundItem = arr.find((item) => item > 10);

console.log(foundItem); // 130 통과가능한 요소중 첫 번째 요소

const users = [
  { name: "Neo", age: 45 },
  { name: "Kato", age: 22 },
  { name: "Amy", age: 17 },
];
const foundUser = users.find((user) => user.name >= "Amy");
console.log(foundUser); // Object { Amy... }
```

```javascript
// .findIndex()  대상 배열에서 콜백 테스트를 통과하는 첫 번째 요소의 인덱스를 반환한다.

const arr = [5, 8, 130, 12, 44];

const index = arr.findIndex((item) => item > 10);
console.log(index); // 2
```

```javascript
// .flat()  대상 배열의 모든 하위 배열을 지정한 깊이까지 이어붙인 새로운 배열을 생성
// 깊이의 기본값은 '1'이다.

const arr = [1. 2 [3, 4, [5, 6]]]

console.log(arr.flat(2)) // [1, 2, 3, 4, 5, 6]
console.log(arr.flat()) // [1, 2, 3, 4, Array(2)]
console.log(arr) // [1, 2, Array(3)]

```

```javascript
// .forEach()  대상 배열의 길이만큼 주어진 콜백을 실행

const arr = ["A", "B", "C"];

arr.forEach((item) => console.log(item));

for (let i = 0; i < arr.length; i += 1) {
  console.log(arr[i]); // A B C A B C
}
```

```javascript
// .includes()  대상 배열이 특정 요소를 포함하고 있는지 확인

const arr = [1, 2, 3];
console.log(arr.includes(6)); // false

const users = [
  { name: "Neo", age: 87 },
  { name: "Amy", age: 11 },
  { name: "Kato", age: 22 },
];
console.log(users.includes({ name: "Neo", age: 87 })); // false
// 원시형과는 다르게 참조형은 비교값이 같더라도 데이터 타입이 다르므로 false값을 출력한다.

const neo = users[0];
console.log(users.includes(neo)); // true
```

```javascript
// .join()  대상 배열의 모든 요소를 구분자로 연결한 문자를 반환한다.

const arr = ["Apple", "Banana", "Cherry"];

console.log(arr.join(",")); //Apple,Banana,Cherry
console.log(arr.join(", ")); // Apple, Banana, Cherry
console.log(arr.join("/")); // Apple/Banana/Cherry
```

```javascript
// .map()  대상 배열의 길이만큼 주어진 콜백을 실행하고, 콜백의 반환 값을 모아 새로운 배열을 반환한다.

const numbers = [1, 2, 3, 4];
const newNumbers = numbers.map((item) => item * 2);

console.log(newNumbers); // [2, 4, 6, 8]
console.log(numbers); // [1, 2, 3, 4]
```

```javascript
// .pop()  대상 배열에서 마지막 요소를 제거하고 그 요소를 반환한다.
// 대상 배열 원본이 변경된다.

const fruits = ["Apple", "Banana", "Cherry"];

console.log(fruits.pop()); // Cherry
console.log(fruits); // ['Apple', 'Banana']
```

```javascript
// .push()  대상 배열의 마지막에 하나 이상의 요소를 추가하고, 배열의 새로운 길이를 반환하고, 대상 배열 원본이 변경된다.

const fruits = ["Apple", "Banana", "Cherry"];

const newLength = fruits.push("Orange");
console.log(newLength); // 4
console.log(fruits); // [.., .., .., Orange]

fruits.push("Mango", "Strawberry");
console.log(fruits); // [.., .., .., Orange, Mango, Strawberry]
```

```javascript
// .reduce()  대상 배열의 길이만큼 주어진 콜백을 실행하고 마지막에 호출되는 콜백의 반환 값을 반환한다. 각 콜백의 반환 값은 다음 콜백으로 전달된다.

const numbers = [1, 2, 3];
const sum = numbers.reduce((accumulator, currentValue) => {
  return accumulator + currentValue;
}, 0); // 0 = 초기값, accumulator = 누적된 값, currentValue = 배열에서 가져온 값
// 6

const users = [
  { name: "Neo", age: 85 },
  { name: "Amy", age: 22 },
  { name: "Lewis", age: 11 },
];

// 총 나이 계산
const totalAge = users.reduce((acc, cur) => {
  return acc + cur.age;
}, 0);
console.log(totalAge); // 118

// 모든 이름 추출
const namesArray = users.reduce((acc, cur) => {
  acc.push(cur, name);
  return acc;
}, []);
const names = namesArray.join(", ");
console.log(names); // Neo, Amy, Lewis
```
